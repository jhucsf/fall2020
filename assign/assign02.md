---
layout: default
title: "Assignment 2: Hex dump"
---

*Preliminary assignment description, not official!*

**Part 1 Due:** Wednesday, September 23, 2020 @ 11pm
**Part 2 Due:** Tuesday, September 28, 2020 @ 11pm

# Overview

In this assignment you will implement a hex dump program using both C and assembly language. The submission of this assignment will be broken up to two parts as listed below.

<<<<<<< Updated upstream
The assembly portion of this assignment is **all** about hacking **native** [x86\_64](https://en.wikipedia.org/wiki/X86-64) assembly code. For obvious reasons, **you’ll need a *64-bit* Lubuntu 18.04 LTS reference
system;** you cannot do this assignment on a 32-bit install. (Note that the ugrad machines should work, but testing on an Ubuntu 18.04-derived system or virtual machine is recommended since it matches what the autograder will be using.)

You’ll use the standard [gcc](http://en.wikipedia.org/wiki/GNU_Compiler_Collection)/[gas](http://en.wikipedia.org/wiki/GNU_Assembler) toolchain and you **must** use AT&T syntax, **not** Intel syntax.

Note that for *all* problems the *full* x86\_64 conventions regarding
register usage (arguments, results, caller-saved vs. callee-saved, etc.)
are in effect\! (Of course regular calls differ from system calls in
this regard.)


**Acknowledgment:** The idea for this assignment comes from the [Fall 2018 HW5](https://www.cs.jhu.edu/~phf/2018/fall/cs229/simple-x86_64.html) developed by Peter Froehlich.
=======
This assignment is **all** about hacking **native**
[x86\_64](https://en.wikipedia.org/wiki/X86-64) assembly code. For obvious reasons, **you’ll need a *64-bit* Lubuntu 18.04 LTS reference system;** you cannot do this assignment on a 32-bit install.(Note that the ugrad machines should work, but testing on an Ubuntu 18.04-derived system or virtual machine is recommended since it matches what the autograder will be using.)

This is a challenging assignment. Don’t wait until the last minute to start it! As usual, ask questions using Piazza, come to office hours, etc.

**Acknowledgment:** The idea for this assignment comes from the [Fall 2018 HW5](https://www.cs.jhu.edu/~phf/2018/fall/cs229/simple-x86_64.html) developed by Peter Frohlich.
>>>>>>> Stashed changes

## Submission Part 1
**Due date 1:** Wednesday, September 23, 2020 @ 11pm

For this submission, all C language function implementations must be working with unit tests written. In addition, _at least_ the Assembly language functions of `hex_to_printable` and `hex_format_byte_as_hex` must be working with unit tests written.

## Submission Part 2
**Due date 2:** Tuesday, September 28, 2020 @ 11pm

Rest of the Assembly language functions must be written with thorough unit tests. Uploads for this submission should include the C implementation and unit tests submitted for part 1 as well.


## Grading breakdown
**Part 1** (30 points)

C implementation - 10%

Assembly implementation - 20%

**Part 2** (70 points)

Assembly implementation - 35%

Unit tests - 20%

Packing, style, and design - 15%


## Getting started

Download [csf\_assign02.zip](csf_assign02.zip), which contains the skeleton code for the assignment.

You can download this file from a Linux command prompt using the `curl` command:

```bash
curl -O https://jhucsf.github.io/fall2020/assign/csf_assign02.zip
```

Note that in the `-O` option, it is the letter "O", not the numeral "0".

# Hex dump

Start by [reading up](http://en.wikipedia.org/wiki/Hex_dump) on what
hexdumps are. For this assignment, you will write a program in C and x86-64 assembly that
produces a hexdump on standard output for data read from standard input.
Let’s start with an example:

    $ ./hex
    Hello
    00000000: 48 65 6c 6c 6f 0a                                Hello.

The program was started, then the user typed the word “Hello” followed
by return/enter, then CTRL-D was used to stop the input. The result
shows the *ASCII code* for each character (in *hexadecimal*, so it’s
guaranteed to be two digits wide for each character), including the
newline character generated by the return/enter key. The formatting may
look a bit strange, but the purpose of the “large gap” becomes apparent
if we examine a longer input:

    $ ./hex
    This is a longer example of a hexdump. Marvel at its magnificence.
    00000000: 54 68 69 73 20 69 73 20 61 20 6c 6f 6e 67 65 72  This is a longer
    00000010: 20 65 78 61 6d 70 6c 65 20 6f 66 20 61 20 68 65   example of a he
    00000020: 78 64 75 6d 70 2e 20 4d 61 72 76 65 6c 20 61 74  xdump. Marvel at
    00000030: 20 69 74 73 20 6d 61 67 6e 69 66 69 63 65 6e 63   its magnificenc
    00000040: 65 2e 0a                                         e..

This time the user entered two sentences, then signaled end of input
with CTRL-D. Again, we see the ASCII code for each character (including
spaces and newlines). The formatting is set up so that regardless of the
number of characters, we always have three “columns” of output:

1.  First the overall “position” in the input. Note that this is also a
    hexadecimal number, **formatted to 8 digits**.
2.  Then the ASCII values for each character in hexadecimal, at most 16
    to a line.
3.  Finally a string-like representation of the data, with printable
    characters shown but non-printable characters (like newline or tab)
    replaced with a dot.

Note that there’s a single space between the colon after the offset and
the ASCII values, but there are *two* spaces between the ASCII values
and the string-like representation.

The behavior of your program should be identical to the command `xxd -g 1`. Take note of how the program will only print a row if it either has a full row of sixteen characters, or if CTRL-D is pressed.

Note that because the purpose of this assignment is to give you an opportunity to learn how to write x86-64 assembly language code, there are some very important [non-functional requirements](#non-functional-requirements) that you will need to satisfy.  (Please read that section of the assignment description carefully.)

# Functional requirements

## Functions

The header file `hexfuncs.h` declares the following functions:

```c
// Read up to 16 bytes from standard input into data_buf.
// Returns the number of characters read.
long hex_read(char data_buf[]);

// Write given nul-terminated string to standard output.
void hex_write_string(const char s[]);

// Format a long value as an offset string consisting of exactly 8
// hex digits.  The formatted offset is stored in sbuf, which must
// have enough room for a string of length 8.
void hex_format_offset(long offset, char sbuf[]);

// Format a byte value (in the range 0-255) as string consisting
// of two hex digits.  The string is stored in sbuf.
void hex_format_byte_as_hex(long byteval, char sbuf[]);

// Convert a byte value (in the range 0-255) to a printable character
// value.  If byteval is already a printable character, it is returned
// unmodified.  If byteval is not a printable character, then the
// ASCII code for '.' should be returned.
long hex_to_printable(long byteval);
```

In both your C and assembly language implementations, you are required to implement these functions exactly as specified.

## Main functions

In `c_hexmain.c` and `asm_hexmain.S`, you will develop C and assembly-language `main` functions which call the functions shown above in order to implement the functionality of the hexdump program.

Note that your main function (either version) may *only* call these functions.

The `c_hexdump` and `asm_hexdump` Makefile targets build executable programs using these `main` modules.  When reading data from standard input, their output should be identical to the command `xxd -g 1`.

The `casm_hexdump` Makefile target builds an executable program which uses the C version of the `main` function, but the assembly-language version of the hex functions.  This is a handy way to test your assembly language function implementations before you have fully implemented the assembly language version of the `main` function.  Its behavior (reading from standard input) should also be identical to `xxd -g 1`.

## Unit tests

The source file `hextests.c` contains unit tests for the required functions.  The provided version is very minimal, so you should add additional tests so that your implementations of the functions are thoroughly tested.  Part of your grade will be based on the thoroughness of your unit tests.

Note that it will not be straightforward to write unit tests for the `hex_read` and `hex_write_string` functions, since they do I/O.  So, you are not required to write unit tests for them.

## Program-level testing

In addition to unit testing individual functions, you should test the program as a whole. In general, for any input file (text, binary, etc.), the command

<pre>
./hex &lt; <i>inputfile</i>
</pre>

should produce exactly the same output as

<pre>
xxd -g 1 &lt; <i>inputfile</i>
</pre>

We encourage you to test your program with a variety of inputs, including (but not limited to):

* empty file
* small files
* large files
* files with sizes that are a multiple of 16
* files with sizes that aren't a multiple of 16
* text files
* binary files

# Non-functional requirements

Calling C library functions is *not* allowed. The only exception is that `c_hexfuncs.c` may `#include <unistd.h>` and call the `read` and `write` functions (which are wrappers for the `read` and `write` system calls). Outside of this singular exception, any call to C library functions will result in an **automatic zero** on the entire assignment. Please don't do it\!

All assembly language code must be 100% written by hand and extensively commented. No credit will be given otherwise. Any undocumented assembly code **will** cause you to lose points. You don’t have to comment **every** line, but at least every “coherent chunk” of assembly should have a comment or two. In particular you **must** describe where you get what data from, especially when it comes to functions and their parameters/results. **You have been warned\!**

# Hints and tips

TODO: add useful info about how to complete the assignment

TODO: recommend an order of how to do things

TODO: emphasize that the assembly language functions must fully conform to the x86-64 calling conventions, otherwise the interoperability with C code won't work

* Writing the `main` function in assembly should be the *last* thing you work on! Make sure that you write robust unit tests for all the helper functions before you try and incorporate them in `main`, so that you can be confident the helper functions work properly which should reduce debugging time!

# Submitting

Submit a zipfile containing your complete project.  The recommended
way to do this is to run the command `make solution.zip`.  This
will create a file called `solution.zip` with all of the required
files.  **Important**: all of the files in the zipfile must be
at the top level, not a subdirectory.  For example, if your
zipfile is called `solution.zip` and you run the command `unzip -l solution.zip`
to list its contents, you should see something like the following output:

```
Archive:  solution.zip
  Length      Date    Time    Name
---------  ---------- -----   ----
     1140  09-13-2020 18:42   Makefile
     1053  09-13-2020 18:42   hexfuncs.h
     3959  09-13-2020 18:42   tctest.h
      884  09-13-2020 18:42   c_hexfuncs.c
      877  09-13-2020 18:42   c_hexmain.c
     1458  09-13-2020 18:42   hextests.c
     3948  09-13-2020 18:42   tctest.c
---------                     -------
    13319                     7 files
```

Upload this zipfile to Gradescope for both parts 1 and 2 of Assignment 2.
Make sure to include your name and email address in *every* file you turn in (well, in every file for which it makes sense to do so anyway!)

# Grading

For reference, here is a short explanation of the grading criteria; some
of the criteria don’t apply to all problems, and not all of the criteria
are used on all assignments.

**Packaging** refers to the proper organization of the stuff you hand
in, following both the guidelines for Deliverables above as well as the
general submission instructions for assignments on
[Piazza](http://piazza.com/jhu/fall2020/601229).

**Style** refers to C/C++/assembly programming style, including things
like consistent indentation, appropriate identifier names, useful
comments, suitable documentation, etc. Simple, clean, readable code is
what you should be aiming for. Make sure you follow the style guide
posted on [Piazza](http://piazza.com/jhu/fall2020/601229)\!

**Design** refers to proper modularization (functions, modules, classes,
etc.) and an appropriate choice of algorithms and data structures.

**Performance** refers to how fast/with how little memory your programs
can produce the required results compared to other submissions.

**Functionality** refers to your programs being able to do what they
should according to the specification given above; if the specification
is ambiguous, ask for clarification\! (It also refers to you simply
doing the required work, which may not be programming alone.)

**If your programs cannot be built you will get no points whatsoever. If
your programs cannot be built without warnings using the required
compiler options given on
[Piazza](http://piazza.com/jhu/fall2020/601229) we will take off 10%
(except if you document a *very* good reason). If your programs cannot
be built using `make` we will take off 10%. If `valgrind` detects memory
errors in your programs, we will take off 10%. If your programs fail
miserably even once, i.e. terminate with an exception of any kind or
dump core, we will take off 10% (for each such case).**
